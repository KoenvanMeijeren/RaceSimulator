<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>E:\Development\C#\RaceSimulator\Controller\Race.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Timers;
using Model;

namespace Controller
{

    public class Race
    {

        public const int 
            StartDistanceOfParticipant = 0, 
            TimerInterval = 500, 
            SectionLength = 100;

        public Track Track { get; private set; }

        public List&lt;IParticipant&gt; Participants { get; private set; }

        public DateTime StartTime { get; private set; }

        private Random _random;

        // Only 2 participants per section are allowed.
        private Dictionary&lt;Section, SectionData&gt; _positions;

        private readonly Timer _timer;

        public static event EventHandler&lt;DriversChangedEventArgs&gt; DriversChanged;

        private static Race _raceReference;

        private static bool _changedDrivers;

        public Race(Track track, List&lt;IParticipant&gt; participants)
        {
            this.Track = track;
            this.Participants = participants;
            this._random = new Random(DateTime.Now.Millisecond);
            this._positions = new Dictionary&lt;Section, SectionData&gt;();
            this._timer = new Timer(Race.TimerInterval);
            this._timer.Elapsed += Race.OnTimedEvent;
            
            this.PlaceParticipantsOnStartPositions();
        }

        public void Start()
        {
            this.StartTime = DateTime.Now;
            this._timer.Enabled = true;
            Race._raceReference = this;
        }

        public static void OnTimedEvent(Object source, ElapsedEventArgs e)
        {
            Race._raceReference.MoveParticipants();
            if (!Race._changedDrivers)
            {
                return;
            }

            Race.DriversChanged?.Invoke(source, new DriversChangedEventArgs(Race._raceReference));
            Race._changedDrivers = false;
        }

        public SectionData GetSectionData(Section section)
        {
            if (!this._positions.Any() || !this._positions.TryGetValue(section, out var foundSectionData))
            {
                foundSectionData = new SectionData();
                this._positions.Add(section, foundSectionData);
            }

            return foundSectionData;
        }

        public bool UpdateSectionData(Section section, SectionData sectionData)
        {
            if (!this._positions.ContainsKey(section))
            {
                return false;
            }

            this._positions[section] = sectionData;
            Race._changedDrivers = true;
            return true;
        }

        private void MoveParticipants()
        {
            Section[] sections = this.Track.Sections.ToArray();
            foreach (Section section in sections)
            {
                SectionData sectionData = this.GetSectionData(section);
                if (sectionData.Left != null &amp;&amp; this.CanMoveParticipant(sectionData.DistanceLeft))
                {
                    sectionData.MoveLeft();
                }

                if (sectionData.Right != null &amp;&amp; this.CanMoveParticipant(sectionData.DistanceRight))
                {
                    sectionData.MoveRight();
                }
                
                this.UpdateSectionData(section, sectionData);
            }
            
            this.MoveParticipantsToNextSectionIfNecessary();
        }

        private void MoveParticipantsToNextSectionIfNecessary()
        {
            Section[] sections = this.Track.Sections.ToArray();
            
            // Determine how many participants should move to the next section. Than move them, if they can move, and
            // re-trigger this method. We do this because it is not always possible to move the participants to the next
            // section. For example if there are participants on the last 2 sections, and they both should move, then we 
            // cannot move them both, because the second last one cannot move to the next section because those
            // participants weren&#39;t move to the next section yet. After the first loop all non-blocking participants
            // were moved to the next section. Now we can move all blocking participants to next section. We repeat this
            // until there are no more participants who should move.
            int sectionsWhichShouldMove = 0;
            foreach (Section section in sections)
            {
                SectionData sectionData = this.GetSectionData(section);
                if (this.ShouldMoveParticipantToNextSection(sectionData))
                {
                    sectionsWhichShouldMove++;
                }
            }

            if (sectionsWhichShouldMove &lt;= 0)
            {
                return;
            }
            
            for (int delta = 0; delta &lt; sections.Length; delta++)
            {
                int nextSectionDelta = (delta + 1) &gt;= sections.Length ? 0 : delta + 1;

                Section
                    section = sections[delta],
                    nextSection = sections[nextSectionDelta];
                SectionData
                    sectionData = this.GetSectionData(section),
                    nextSectionData = this.GetSectionData(nextSection);
                
                if (this.ShouldMoveParticipantsToNextSection(sectionData))
                {
                    nextSectionData = this.MoveParticipantsToNextSection(
                        sectionData, nextSectionData, sectionData.Left, sectionData.Right
                    );
                    
                    this.UpdateSectionData(nextSection, nextSectionData);
                    this.UpdateSectionData(section, sectionData);
                }
                else if (this.ShouldMoveParticipantToNextSection(sectionData))
                {
                    IParticipant participant = this.GetParticipantWhoShouldMoveToNextSection(sectionData);
                
                    nextSectionData = this.MoveParticipantToNextSection(
                        sectionData, nextSectionData, participant
                    );
                    
                    this.UpdateSectionData(nextSection, nextSectionData);
                    this.UpdateSectionData(section, sectionData);
                }
            }

            this.MoveParticipantsToNextSectionIfNecessary();
        }

        private bool CanMoveParticipant(int distance)
        {
            return distance &lt; Race.SectionLength;
        }
        
        private bool ShouldMoveParticipantToNextSection(SectionData sectionData)
        {
            return (sectionData.DistanceLeft &gt;= Race.SectionLength &amp;&amp; sectionData.Left != null) 
                   || (sectionData.DistanceRight &gt;= Race.SectionLength &amp;&amp; sectionData.Right != null);
        }

        private bool ShouldMoveParticipantsToNextSection(SectionData sectionData)
        {
            return sectionData.DistanceLeft &gt;= Race.SectionLength &amp;&amp; sectionData.Left != null
                   &amp;&amp; sectionData.DistanceRight &gt;= Race.SectionLength &amp;&amp; sectionData.Right != null;
        }

        private IParticipant GetParticipantWhoShouldMoveToNextSection(SectionData sectionData)
        {
            if (!this.ShouldMoveParticipantToNextSection(sectionData))
            {
                return null;
            }

            return sectionData.DistanceLeft &gt;= Race.SectionLength ? sectionData.Left : sectionData.Right;
        }

        private SectionData MoveParticipantToNextSection(SectionData sectionData, SectionData nextSectionData, IParticipant participant)
        {
            if (!this.CanPlaceParticipant(nextSectionData, participant))
            {
                return nextSectionData;
            }
            
            nextSectionData = this.ParticipantToSectionData(nextSectionData, participant);
            sectionData.Clear(participant);

            return nextSectionData;
        }

        private SectionData MoveParticipantsToNextSection(SectionData sectionData, SectionData nextSectionData, IParticipant participantLeft, IParticipant participantRight)
        {
            if (!this.CanPlaceParticipants(nextSectionData, participantLeft, participantRight))
            {
                return nextSectionData;
            }
            
            nextSectionData = this.ParticipantsToSectionData(nextSectionData, participantLeft, participantRight);
            sectionData.Clear(participantLeft, participantRight);

            return nextSectionData;
        }

        // @todo find out what we should do when there are more participants than start grids.
        private void PlaceParticipantsOnStartPositions()
        {
            List&lt;IParticipant&gt; participants = this.Participants.ToList();
            Section[] sections = this.Track.Sections.ToArray();

            for (int delta = 0; delta &lt; sections.Length; delta++)
            {
                Section section = sections[delta];
                SectionData sectionData = this.GetSectionData(section);

                if (!this.CanPlaceParticipantsOnStartPosition(section.SectionType))
                {
                    continue;
                }

                IParticipant participantOne = participants.ElementAtOrDefault(0);
                IParticipant participantTwo = participants.ElementAtOrDefault(1);
                bool 
                    canPlaceBoth = this.CanPlaceParticipants(sectionData, participantOne, participantTwo),
                    canPlaceOne = this.CanPlaceParticipant(sectionData, participantOne);

                if (!canPlaceBoth &amp;&amp; canPlaceOne)
                {
                    sectionData = this.ParticipantToSectionData(sectionData, participantOne);
                    participants.RemoveAt(0);
                }
                else if (canPlaceBoth)
                {
                    sectionData = this.ParticipantsToSectionData(sectionData, participantOne, participantTwo);
                    participants.RemoveAt(0);
                    participants.RemoveAt(0);
                }

                this.UpdateSectionData(section, sectionData);
            }
        }

        private bool CanPlaceParticipantsOnStartPosition(SectionTypes sectionType)
        {
            return sectionType == SectionTypes.StartGrid;
        }

        private bool CanPlaceParticipants(SectionData sectionData, IParticipant leftParticipant, IParticipant rightParticipant)
        {
            if (leftParticipant == null || rightParticipant == null)
            {
                return false;
            }

            return sectionData.Left == null &amp;&amp; sectionData.Right == null;
        }

        private bool CanPlaceParticipant(SectionData sectionData, IParticipant participant)
        {
            if (participant == null)
            {
                return false;
            }

            return this.CanPlaceLeftParticipant(sectionData) || this.CanPlaceRightParticipant(sectionData);
        }

        private bool CanPlaceLeftParticipant(SectionData sectionData)
        {
            return sectionData.Left == null &amp;&amp; (sectionData.Right != null || sectionData.Right == null);
        }

        private bool CanPlaceRightParticipant(SectionData sectionData)
        {
            return sectionData.Right == null &amp;&amp; (sectionData.Left != null || sectionData.Left == null);
        }

        // @todo implement distance between participants calculation.
        private SectionData ParticipantsToSectionData(SectionData sectionData, IParticipant leftParticipant, IParticipant rightParticipant)
        {
            if (!this.CanPlaceParticipants(sectionData, leftParticipant, rightParticipant))
            {
                return null;
            }

            int defaultDistance = Race.StartDistanceOfParticipant;

            return new SectionData(leftParticipant, defaultDistance, rightParticipant, defaultDistance);
        }

        private SectionData ParticipantToSectionData(SectionData sectionData, IParticipant participant)
        {
            int defaultDistance = Race.StartDistanceOfParticipant;

            if (this.CanPlaceLeftParticipant(sectionData))
            {
                return new SectionData(participant, defaultDistance, sectionData.Right, defaultDistance);
            }

            if (this.CanPlaceRightParticipant(sectionData))
            {
                return new SectionData(sectionData.Left, defaultDistance, participant, defaultDistance);
            }

            return null;
        }

        private void RandomizeEquipment()
        {
            foreach (IParticipant participant in this.Participants)
            {
                IEquipment equipment = participant.Equipment;
                equipment.SetRandomPerformance();
                equipment.SetRandomQuality();
            }
        }

        public static int ConvertRange(int originalStart, int originalEnd, int newStart, int newEnd, int value)
        {
            double scale = (double)(newEnd - newStart) / (originalEnd - originalStart);
            
            return (int)(newStart + ((value - originalStart) * scale));
        }
        
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[20,30,20,34,1],[20,35,20,47,1],[22,50,22,54,1],[22,55,22,67,1],[24,37,24,41,1],[24,42,24,54,1],[39,9,39,66,1],[40,9,40,10,1],[41,13,41,32,1],[42,13,42,46,1],[43,13,43,65,1],[44,13,44,70,1],[45,13,45,57,1],[46,13,46,54,1],[48,13,48,54,1],[49,9,49,10,1],[52,9,52,10,1],[53,13,53,43,1],[54,13,54,40,1],[55,13,55,40,1],[56,9,56,10,1],[59,9,59,10,1],[60,13,60,52,1],[61,13,61,39,1],[62,13,62,14,0],[63,17,63,24,0],[66,13,66,99,1],[67,13,67,42,1],[68,9,68,10,1],[71,9,71,10,1],[72,13,72,107,1],[73,13,73,14,1],[74,17,74,54,1],[75,17,75,64,1],[76,13,76,14,1],[78,13,78,37,1],[79,9,79,10,1],[82,9,82,10,1],[83,13,83,55,1],[84,13,84,14,1],[85,17,85,30,1],[88,13,88,52,1],[89,13,89,41,1],[90,13,90,25,1],[91,9,91,10,1],[94,9,94,10,1],[95,13,95,64,1],[96,13,96,20,1],[96,22,96,37,1],[96,38,96,40,1],[96,41,96,49,1],[97,13,97,14,1],[98,17,98,72,1],[99,17,99,99,1],[100,17,100,18,1],[101,21,101,44,1],[102,17,102,18,1],[104,17,104,101,1],[105,17,105,18,1],[106,21,106,45,1],[107,17,107,18,1],[109,17,109,62,1],[110,13,110,14,1],[112,13,112,61,1],[113,9,113,10,1],[116,9,116,10,1],[117,13,117,64,1],[126,13,126,45,1],[127,13,127,20,1],[127,22,127,37,1],[127,38,127,40,1],[127,41,127,49,1],[128,13,128,14,1],[129,17,129,72,1],[130,17,130,74,1],[131,17,131,18,1],[132,21,132,47,1],[133,17,133,18,1],[134,13,134,14,1],[136,13,136,46,1],[137,13,137,14,1],[138,17,138,24,1],[141,18,141,31,1],[141,33,141,56,1],[141,58,141,65,1],[142,13,142,14,1],[143,17,143,87,1],[145,17,146,46,1],[147,21,147,61,1],[148,17,149,63,1],[150,21,150,71,1],[152,17,152,75,1],[153,17,153,18,1],[154,21,156,23,1],[158,21,158,74,1],[159,21,159,66,1],[160,17,160,18,1],[161,22,161,79,1],[162,17,162,18,1],[163,21,163,107,1],[165,21,167,23,1],[169,21,169,74,1],[170,21,170,66,1],[171,17,171,18,1],[172,13,172,14,1],[174,13,174,61,1],[175,9,175,10,1],[178,9,178,10,1],[179,13,179,50,1],[180,9,180,10,1],[183,9,183,10,1],[184,13,185,102,1],[186,9,186,10,1],[189,9,189,10,1],[190,13,191,100,1],[192,9,192,10,1],[195,9,195,10,1],[196,13,196,71,1],[197,13,197,14,0],[198,17,198,29,0],[201,13,201,106,1],[202,9,202,10,1],[205,9,205,10,1],[206,13,206,73,1],[207,13,207,14,0],[208,17,208,40,0],[211,13,211,91,1],[212,13,212,44,1],[214,13,214,36,1],[215,9,215,10,1],[218,9,218,10,1],[219,13,219,96,1],[220,13,220,14,0],[221,17,221,40,0],[224,13,224,114,1],[225,13,225,66,1],[227,13,227,36,1],[228,9,228,10,1],[232,9,232,10,1],[233,13,233,74,1],[234,13,234,64,1],[236,18,236,31,1],[236,33,236,56,1],[236,58,236,65,1],[237,13,237,14,1],[238,17,238,51,1],[239,17,239,72,1],[241,17,241,84,1],[242,17,242,18,1],[243,21,243,30,1],[246,17,246,82,1],[247,17,247,82,1],[248,17,249,106,1],[250,21,250,88,1],[252,17,252,50,1],[253,17,253,18,1],[254,21,254,94,1],[255,21,255,46,1],[256,17,256,18,1],[257,22,257,39,1],[258,17,258,18,1],[259,21,259,111,1],[260,21,260,46,1],[261,21,261,46,1],[262,17,262,18,1],[264,17,264,62,1],[265,13,265,14,1],[266,9,266,10,1],[269,9,269,10,1],[270,13,270,58,1],[271,9,271,10,1],[274,9,274,10,1],[275,13,275,69,1],[276,13,276,14,1],[277,17,277,30,1],[280,13,280,74,1],[281,9,281,10,1],[284,9,284,10,1],[285,13,285,37,1],[286,13,286,14,1],[287,17,287,30,1],[290,13,290,108,1],[291,9,291,10,1],[294,9,294,10,1],[295,13,295,105,1],[296,9,296,10,1],[299,9,299,10,0],[300,13,300,104,0],[301,9,301,10,0],[305,9,305,10,1],[306,13,306,92,1],[307,13,307,14,0],[308,17,308,29,0],[311,13,311,67,1],[313,13,313,105,1],[314,9,314,10,1],[317,9,317,10,1],[318,13,318,67,1],[320,13,320,59,1],[321,13,321,14,1],[322,17,322,106,1],[325,13,325,60,0],[326,13,326,14,0],[327,17,327,105,0],[330,13,330,25,0],[331,9,331,10,1],[334,9,334,10,0],[335,13,335,20,0],[335,22,335,46,0],[335,47,335,49,0],[335,50,335,67,0],[336,13,336,14,0],[337,17,337,62,0],[338,17,338,50,0],[339,17,339,46,0],[340,13,340,14,0],[341,9,341,10,0],[344,9,344,10,1],[345,13,345,88,1],[347,13,347,72,1],[348,9,348,10,1]]);
    </script>
  </body>
</html>