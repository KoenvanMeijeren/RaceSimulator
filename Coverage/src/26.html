<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>E:\Development\C#\RaceSimulator\Controller\Race.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Timers;
using Model;

namespace Controller
{

    public class Race
    {

        private const int
            StartDistanceOfParticipant = 0,
            TimerInterval = 500,
            RoundsStartValue = 0,
            MaxRounds = 2;
        
        public const int SectionLength = IEquipment.MaximumPerformance * IEquipment.MaximumSpeed;

        private int _finishedParticipants = 0;

        public Track Track { get; private set; }

        public List&lt;IParticipant&gt; Participants { get; private set; }

        public DateTime StartTime { get; private set; }

        private readonly Random _random;

        // Only 2 participants per section are allowed.
        private readonly Dictionary&lt;Section, SectionData&gt; _positions;

        private readonly Dictionary&lt;IParticipant, int&gt; _rounds;

        private readonly Timer _timer;

        public static event EventHandler&lt;DriversChangedEventArgs&gt; DriversChanged;
        
        public static event EventHandler&lt;DriversChangedEventArgs&gt; RaceEnded;

        private static Race _raceReference;

        public Race(Track track, List&lt;IParticipant&gt; participants)
        {
            this.Track = track;
            this.Participants = participants;
            this._random = new Random(DateTime.Now.Millisecond);
            this._positions = new Dictionary&lt;Section, SectionData&gt;();
            this._rounds = new Dictionary&lt;IParticipant, int&gt;(participants.Capacity);
            this._timer = new Timer(Race.TimerInterval);
            this._timer.Elapsed += Race.OnTimedEvent;
            
            this.PlaceParticipantsOnStartPositions();
        }

        public void Start()
        {
            this.StartTime = DateTime.Now;
            this._timer.Enabled = true;
            Race._raceReference = this;
        }

        public void End()
        {
            this._timer.Close();
            this._timer.Enabled = false;
            Race.DriversChanged = null;
            Race._raceReference = null;
        }

        public static void DestructAllEvents()
        {
            Race.DriversChanged = null;
            Race.RaceEnded = null;
        }

        public static void OnTimedEvent(object source, ElapsedEventArgs e)
        {
            if (Race._raceReference.AllParticipantsFinished())
            {
                Race._raceReference.End();
                Race.RaceEnded?.Invoke(source, new DriversChangedEventArgs(Race._raceReference));
                return;
            }
            
            Race._raceReference.MoveParticipants();
            Race.DriversChanged?.Invoke(source, new DriversChangedEventArgs(Race._raceReference));
        }

        private void MoveParticipants()
        {
            Section[] sections = this.Track.Sections.ToArray();
            for (int delta = 0; delta &lt; sections.Length; delta++)
            {
                int nextSectionDelta = (delta + 1) &gt;= sections.Length ? 0 : delta + 1;

                Section
                    section = sections[delta],
                    nextSection = sections[nextSectionDelta];
                SectionData
                    sectionData = this.GetSectionData(section),
                    nextSectionData = this.GetSectionData(nextSection);
                
                if (sectionData.Left != null &amp;&amp; this.CanMoveParticipant(sectionData.DistanceLeft))
                {
                    sectionData.MoveLeft();
                    switch (sectionData.Left.Equipment.IsBroken)
                    {
                        case false when this.ShouldBreakParticipantEquipment():
                            sectionData.BreakEquipmentLeft();
                            this.UpdateSectionData(section, sectionData);
                            continue;
                        case true when this.ShouldFixParticipantEquipment():
                            sectionData.FixEquipmentLeft();
                            break;
                    }

                    this.UpdateSectionData(section, sectionData);
                }

                if (sectionData.Right != null &amp;&amp; this.CanMoveParticipant(sectionData.DistanceRight))
                {
                    sectionData.MoveRight();
                    switch (sectionData.Right.Equipment.IsBroken)
                    {
                        case false when this.ShouldBreakParticipantEquipment():
                            sectionData.BreakEquipmentRight();
                            this.UpdateSectionData(section, sectionData);
                            continue;
                        case true when this.ShouldFixParticipantEquipment():
                            sectionData.FixEquipmentRight();
                            break;
                    }

                    this.UpdateSectionData(section, sectionData);
                }
                
                this.MoveParticipantsToNextSectionIfNecessary(section, sectionData, nextSection, nextSectionData);
            }
        }

        private void MoveParticipantsToNextSectionIfNecessary(Section section, SectionData sectionData, Section nextSection, SectionData nextSectionData)
        {
            if (this.ShouldMoveParticipantsToNextSection(sectionData) &amp;&amp; this.CanPlaceParticipants(nextSectionData, sectionData.Left, sectionData.Right))
            {
                nextSectionData = this.MoveParticipantsToNextSection(
                    sectionData, nextSection, nextSectionData, sectionData.Left, sectionData.Right
                );

                if (section.SectionType == SectionTypes.Finish)
                {
                    int roundsLeft = this.GetRounds(nextSectionData.Left);
                    this.UpdateRounds(nextSectionData.Left, roundsLeft + 1);
                
                    int roundsRight = this.GetRounds(nextSectionData.Right);
                    this.UpdateRounds(nextSectionData.Right, roundsRight + 1);

                    nextSectionData = this.RemoveParticipantsOnTrackCompletion(nextSectionData, nextSectionData.Left, roundsLeft);
                    nextSectionData = this.RemoveParticipantsOnTrackCompletion(nextSectionData, nextSectionData.Right, roundsRight);
                }

                this.UpdateSectionData(nextSection, nextSectionData);
                this.UpdateSectionData(section, sectionData);
            }
            else if (this.ShouldMoveParticipantToNextSection(sectionData) &amp;&amp; this.CanPlaceParticipant(nextSectionData, this.GetParticipantWhoShouldMoveToNextSection(sectionData)))
            {
                IParticipant participant = this.GetParticipantWhoShouldMoveToNextSection(sectionData);
                
                nextSectionData = this.MoveParticipantToNextSection(
                    sectionData, nextSection, nextSectionData, participant
                );

                if (section.SectionType == SectionTypes.Finish)
                {
                    int rounds = this.GetRounds(participant);
                    this.UpdateRounds(participant, rounds + 1);
                    
                    nextSectionData = this.RemoveParticipantsOnTrackCompletion(nextSectionData, participant, rounds);
                }

                this.UpdateSectionData(nextSection, nextSectionData);
                this.UpdateSectionData(section, sectionData);
            }
        }

        private SectionData MoveParticipantToNextSection(SectionData sectionData, Section nextSection, SectionData nextSectionData, IParticipant participant)
        {
            if (!this.CanPlaceParticipant(nextSectionData, participant))
            {
                return nextSectionData;
            }
            
            SectionData updatedSectionData = this.ParticipantToSectionData(nextSection, nextSectionData, participant);
            if (updatedSectionData == null)
            {
                return nextSectionData;
            }
            
            sectionData.Clear(participant);
            return updatedSectionData;

        }

        private SectionData MoveParticipantsToNextSection(SectionData sectionData, Section nextSection, SectionData nextSectionData, IParticipant participantLeft, IParticipant participantRight)
        {
            if (!this.CanPlaceParticipants(nextSectionData, participantLeft, participantRight))
            {
                return nextSectionData;
            }
            
            SectionData updatedSectionData = this.ParticipantsToSectionData(nextSection, nextSectionData, participantLeft, participantRight);
            if (updatedSectionData == null)
            {
                return nextSectionData;
            }
            
            sectionData.Clear(participantLeft, participantRight);
            return updatedSectionData;

        }

        private void PlaceParticipantsOnStartPositions()
        {
            List&lt;IParticipant&gt; participants = this.Participants.ToList();
            Section[] sections = this.Track.Sections.ToArray();

            foreach (var section in sections)
            {
                SectionData sectionData = this.GetSectionData(section);

                if (!this.CanPlaceParticipantsOnStartPosition(section.SectionType))
                {
                    continue;
                }

                IParticipant participantOne = participants.ElementAtOrDefault(0);
                IParticipant participantTwo = participants.ElementAtOrDefault(1);
                bool 
                    canPlaceBoth = this.CanPlaceParticipants(sectionData, participantOne, participantTwo),
                    canPlaceOne = this.CanPlaceParticipant(sectionData, participantOne);

                switch (canPlaceBoth)
                {
                    case false when canPlaceOne:
                        sectionData = this.ParticipantToSectionData(section, sectionData, participantOne);
                        participants.RemoveAt(0);
                        break;
                    case true:
                        sectionData = this.ParticipantsToSectionData(section, sectionData, participantOne, participantTwo);
                        participants.RemoveAt(0);
                        participants.RemoveAt(0);
                        break;
                }

                this.UpdateSectionData(section, sectionData);
            }
        }

        private SectionData ParticipantsToSectionData(Section section, SectionData sectionData, IParticipant leftParticipant, IParticipant rightParticipant)
        {
            if (!this.CanPlaceParticipants(sectionData, leftParticipant, rightParticipant))
            {
                return null;
            }

            int defaultDistance = Race.StartDistanceOfParticipant;

            return new SectionData(section, leftParticipant, defaultDistance, rightParticipant, defaultDistance);
        }

        private SectionData ParticipantToSectionData(Section section, SectionData sectionData, IParticipant participant)
        {
            int defaultDistance = Race.StartDistanceOfParticipant;

            if (this.CanPlaceLeftParticipant(sectionData))
            {
                return new SectionData(section, participant, defaultDistance, sectionData.Right, defaultDistance);
            }

            if (this.CanPlaceRightParticipant(sectionData))
            {
                return new SectionData(section, sectionData.Left, defaultDistance, participant, defaultDistance);
            }

            return null;
        }
        
        private bool ShouldBreakParticipantEquipment()
        {
            int yes = 0;
            const int iterations = 500;
            for (int delta = 0; delta &lt; iterations; delta++)
            {
                if (this._random.Next(1, 101) &lt;= 25)
                {
                    yes++;
                }
            }

            double result = (double) yes / iterations;
            result *= 100;

            return result &gt; 30;
        }
        
        public bool ShouldFixParticipantEquipment()
        {
            int yes = 0;
            const int iterations = 500;
            for (int delta = 0; delta &lt; iterations; delta++)
            {
                if (this._random.Next(1, 101) &lt;= 30)
                {
                    yes++;
                }
            }

            double result = (double) yes / iterations;
            result *= 100;

            return result &gt; 32;
        }
        
        public SectionData RemoveParticipantsOnTrackCompletion(SectionData sectionData, IParticipant participant, int rounds)
        {
            if (rounds &lt; Race.MaxRounds)
            {
                return sectionData;
            }
            
            this._finishedParticipants++;
            sectionData.Clear(participant);

            return sectionData;
        }
        
        private bool AllParticipantsFinished()
        {
            return this._finishedParticipants &gt;= this.Participants.Count;
        }
        
        public SectionData GetSectionData(Section section)
        {
            if (this._positions.TryGetValue(section, out var foundSectionData))
            {
                return foundSectionData;
            }
            
            foundSectionData = new SectionData();
            this._positions.Add(section, foundSectionData);

            return foundSectionData;
        }

        public bool UpdateSectionData(Section section, SectionData sectionData)
        {
            if (!this._positions.ContainsKey(section))
            {
                return false;
            }

            this._positions[section] = sectionData;
            return true;
        }
        
        public int GetRounds(IParticipant participant)
        {
            if (this._rounds.TryGetValue(participant, out var rounds))
            {
                return rounds;
            }
            
            rounds = Race.RoundsStartValue;
            this._rounds.Add(participant, rounds);

            return rounds;
        }

        public bool UpdateRounds(IParticipant participant, int rounds)
        {
            if (!this._rounds.ContainsKey(participant))
            {
                return false;
            }

            this._rounds[participant] = rounds;
            return true;
        }
        
        private bool CanMoveParticipant(int distance)
        {
            return distance &lt; Race.SectionLength;
        }
        
        private bool ShouldMoveParticipantToNextSection(SectionData sectionData)
        {
            return (sectionData.DistanceLeft &gt;= Race.SectionLength &amp;&amp; sectionData.Left != null) 
                   || (sectionData.DistanceRight &gt;= Race.SectionLength &amp;&amp; sectionData.Right != null);
        }

        private bool ShouldMoveParticipantsToNextSection(SectionData sectionData)
        {
            return sectionData.DistanceLeft &gt;= Race.SectionLength &amp;&amp; sectionData.Left != null 
                    &amp;&amp; sectionData.DistanceRight &gt;= Race.SectionLength &amp;&amp; sectionData.Right != null;
        }

        private IParticipant GetParticipantWhoShouldMoveToNextSection(SectionData sectionData)
        {
            if (!this.ShouldMoveParticipantToNextSection(sectionData))
            {
                return null;
            }

            return sectionData.DistanceLeft &gt;= Race.SectionLength ? sectionData.Left : sectionData.Right;
        }
        
        private bool CanPlaceParticipantsOnStartPosition(SectionTypes sectionType)
        {
            return sectionType == SectionTypes.StartGrid;
        }

        private bool CanPlaceParticipants(SectionData sectionData, IParticipant leftParticipant, IParticipant rightParticipant)
        {
            if (leftParticipant == null || rightParticipant == null)
            {
                return false;
            }

            return sectionData.Left == null &amp;&amp; sectionData.Right == null;
        }

        private bool CanPlaceParticipant(SectionData sectionData, IParticipant participant)
        {
            if (participant == null)
            {
                return false;
            }

            return this.CanPlaceLeftParticipant(sectionData) || this.CanPlaceRightParticipant(sectionData);
        }

        private bool CanPlaceLeftParticipant(SectionData sectionData)
        {
            return sectionData.Left == null;
        }

        private bool CanPlaceRightParticipant(SectionData sectionData)
        {
            return sectionData.Right == null;
        }

        public static int ConvertRange(int originalStart, int originalEnd, int newStart, int newEnd, int value)
        {
            double scale = (double)(newEnd - newStart) / (originalEnd - originalStart);
            
            return (int)(newStart + ((value - originalStart) * scale));
        }
        
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[21,9,21,47,1],[23,30,23,34,1],[23,35,23,47,1],[25,50,25,54,1],[25,55,25,67,1],[27,37,27,41,1],[27,42,27,54,1],[44,9,44,66,1],[45,9,45,10,1],[46,13,46,32,1],[47,13,47,46,1],[48,13,48,65,1],[49,13,49,70,1],[50,13,50,85,1],[51,13,51,57,1],[52,13,52,54,1],[54,13,54,54,1],[55,9,55,10,1],[58,9,58,10,1],[59,13,59,43,1],[60,13,60,40,1],[61,13,61,40,1],[62,9,62,10,1],[65,9,65,10,1],[66,13,66,33,1],[67,13,67,41,1],[68,13,68,40,1],[69,13,69,40,1],[70,9,70,10,1],[73,9,73,10,1],[74,13,74,40,1],[75,13,75,35,1],[76,9,76,10,1],[79,9,79,10,1],[80,13,80,63,1],[81,13,81,14,0],[82,17,82,43,0],[83,17,83,98,0],[84,17,84,24,0],[87,13,87,52,1],[88,13,88,99,1],[89,9,89,10,1],[92,9,92,10,1],[93,13,93,64,1],[94,18,94,31,1],[94,33,94,56,1],[94,58,94,65,1],[95,13,95,14,1],[96,17,96,87,1],[98,17,99,46,1],[100,21,100,61,1],[101,17,102,63,1],[103,21,103,71,1],[105,17,105,99,1],[106,17,106,18,1],[107,21,107,44,1],[108,21,108,65,1],[110,36,110,79,1],[111,29,111,62,0],[112,29,112,74,0],[113,29,113,38,0],[114,35,114,76,0],[115,29,115,60,0],[116,29,116,35,0],[119,21,119,66,1],[120,17,120,18,1],[122,17,122,101,1],[123,17,123,18,1],[124,21,124,45,1],[125,21,125,66,1],[127,36,127,79,1],[128,29,128,63,0],[129,29,129,74,0],[130,29,130,38,0],[131,35,131,76,0],[132,29,132,61,0],[133,29,133,35,0],[136,21,136,66,1],[137,17,137,18,1],[139,17,139,115,1],[140,13,140,14,1],[141,9,141,10,1],[144,9,144,10,1],[145,13,145,154,1],[146,13,146,14,1],[147,17,149,19,1],[151,17,151,64,1],[152,17,152,18,1],[153,21,153,75,1],[154,21,154,77,1],[156,21,156,77,1],[157,21,157,79,1],[159,21,159,131,1],[160,21,160,133,1],[161,17,161,18,1],[163,17,163,70,1],[164,17,164,62,1],[165,13,165,14,1],[166,18,166,180,1],[167,13,167,14,1],[168,17,168,103,1],[170,17,172,19,1],[174,17,174,64,1],[175,17,175,18,1],[176,21,176,62,1],[177,21,177,64,1],[179,21,179,118,1],[180,17,180,18,1],[182,17,182,70,1],[183,17,183,62,1],[184,13,184,14,1],[185,9,185,10,1],[188,9,188,10,1],[189,13,189,73,1],[190,13,190,14,0],[191,17,191,40,0],[194,13,194,119,1],[195,13,195,44,1],[196,13,196,14,0],[197,17,197,40,0],[200,13,200,44,1],[201,13,201,39,1],[203,9,203,10,1],[206,9,206,10,1],[207,13,207,96,1],[208,13,208,14,0],[209,17,209,40,0],[212,13,212,142,1],[213,13,213,44,1],[214,13,214,14,0],[215,17,215,40,0],[218,13,218,66,1],[219,13,219,39,1],[221,9,221,10,1],[224,9,224,10,1],[225,13,225,74,1],[226,13,226,64,1],[228,13,228,20,1],[228,22,228,33,1],[228,34,228,36,1],[228,37,228,45,1],[229,13,229,14,1],[230,17,230,72,1],[232,17,232,84,1],[233,17,233,18,1],[234,21,234,30,1],[237,17,237,82,1],[238,17,238,82,1],[239,17,240,106,1],[241,21,241,88,1],[243,17,243,38,1],[245,32,245,48,1],[246,25,246,107,1],[247,25,247,50,1],[248,25,248,31,1],[250,25,250,124,1],[251,25,251,50,1],[252,25,252,50,1],[253,25,253,31,1],[256,17,256,62,1],[257,13,257,14,1],[258,9,258,10,1],[261,9,261,10,1],[262,13,262,92,1],[263,13,263,14,0],[264,17,264,29,0],[267,13,267,67,1],[269,13,269,114,1],[270,9,270,10,1],[273,9,273,10,1],[274,13,274,67,1],[276,13,276,59,1],[277,13,277,14,1],[278,17,278,115,1],[281,13,281,60,1],[282,13,282,14,1],[283,17,283,114,1],[286,13,286,25,0],[287,9,287,10,1],[290,9,290,10,1],[291,13,291,25,1],[293,18,293,31,1],[293,33,293,51,1],[293,53,293,60,1],[294,13,294,14,1],[295,17,295,53,1],[296,17,296,18,1],[297,21,297,27,1],[298,17,298,18,1],[299,13,299,14,1],[301,13,301,55,1],[302,13,302,27,1],[304,13,304,32,1],[305,9,305,10,1],[308,9,308,10,1],[309,13,309,25,1],[311,18,311,31,1],[311,33,311,51,1],[311,53,311,60,1],[312,13,312,14,1],[313,17,313,53,1],[314,17,314,18,1],[315,21,315,27,1],[316,17,316,18,1],[317,13,317,14,1],[319,13,319,55,1],[320,13,320,27,1],[322,13,322,32,1],[323,9,323,10,1],[326,9,326,10,1],[327,13,327,41,1],[328,13,328,14,1],[329,17,329,36,1],[332,13,332,42,1],[333,13,333,44,1],[335,13,335,32,1],[336,9,336,10,1],[339,9,339,10,1],[340,13,340,74,1],[341,9,341,10,1],[344,9,344,10,1],[345,13,345,80,1],[346,13,346,14,1],[347,17,347,41,1],[350,13,350,50,1],[351,13,351,60,1],[353,13,353,37,1],[354,9,354,10,1],[357,9,357,10,1],[358,13,358,55,1],[359,13,359,14,1],[360,17,360,30,1],[363,13,363,52,1],[364,13,364,25,1],[365,9,365,10,1],[368,9,368,10,1],[369,13,369,71,1],[370,13,370,14,1],[371,17,371,31,1],[374,13,374,44,1],[375,13,375,51,1],[377,13,377,27,1],[378,9,378,10,1],[381,9,381,10,1],[382,13,382,56,1],[383,13,383,14,1],[384,17,384,30,1],[387,13,387,48,1],[388,13,388,25,1],[389,9,389,10,1],[392,9,392,10,1],[393,13,393,50,1],[394,9,394,10,1],[397,9,397,10,1],[398,13,399,102,1],[400,9,400,10,1],[403,9,403,10,1],[404,13,405,101,1],[406,9,406,10,1],[409,9,409,10,1],[410,13,410,71,1],[411,13,411,14,0],[412,17,412,29,0],[415,13,415,106,1],[416,9,416,10,1],[419,9,419,10,1],[420,13,420,58,1],[421,9,421,10,1],[424,9,424,10,1],[425,13,425,69,1],[426,13,426,14,1],[427,17,427,30,1],[430,13,430,74,1],[431,9,431,10,1],[434,9,434,10,1],[435,13,435,37,1],[436,13,436,14,1],[437,17,437,30,1],[440,13,440,108,1],[441,9,441,10,1],[444,9,444,10,1],[445,13,445,45,1],[446,9,446,10,1],[449,9,449,10,1],[450,13,450,46,1],[451,9,451,10,1],[454,9,454,10,1],[455,13,455,88,1],[457,13,457,72,1],[458,9,458,10,1]]);
    </script>
  </body>
</html>